**前言**
JS 模块是前端工程化的基础。

## 模块基础

**模块模式** 的思想：把逻辑分块、各自封装、相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。

### 模块标识符
模块系统本质上是 `键/值` 实体，必须要有一个标识符来引用这些实体。这个标识符可能是字符串，也可能是模块文件的路径。

将模块标识符解析为实际模块的过程要根据模块系统对标识符的实现。

在浏览器中，模块标识符必须提供实际 JS 文件路径。

Node.js 还会搜索 node_modules 目录，用标识符去匹配包含 index.js 目录。

### 模块依赖
模块系统的核心是管理依赖，指定依赖的模块与周围的环境会达成一种契约。模块系统检视这些依赖进而保证外部模块能够被加载并在本地模块运行时初始化所有依赖。

### 模块加载
加载模块步骤：
1. 加载(入口)模块中的代码，并加载其中涉及的依赖
2. 若浏览器没有收到依赖模块的代码，其会发送请求并等待网络返回
3. 浏览器会确认刚收到的模块是否也有依赖，然后递归地评估并加载所有依赖，知道所有依赖模块都加载完成
4. 当整个依赖图都加载完成后，执行入口模块

**入口**

相互依赖的模块必须指定一个模块作为入口，这也是代码执行的起点。模块加载是“阻塞的”，这意味着前置操作完成之后才能执行后续操作。

**异步依赖**

为了提高性能，有时我们希望按需加载。换句话说就是让 JS 通知模块系统在必要时加载新模块，并在模块加载完成之后提供回调，如下伪代码所示：
```js
// 在模块A里面
load('moduleB').then(function (moduleB) {
	moduleB.doStuff();
})
```

**动态依赖**

有的模块系统允许开发者在程序结构中动态添加依赖。
```js
if (loadCondition) {
	require('./moduleA');
}
```

动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。

**静态分析**

对静态分析友好的模块系统可以让模块打包系统时更容易将代码处理为较少的文件。在静态分析中，打包系统能判断出哪些模块不打包也没关系，但是在动态依赖中则无法判断，因此需要把涉及的都打包进来。

**循环依赖**

CommonJS、AMD 和 ES6 在内的所有模块系统都支持循环依赖。在包含循环依赖的应用程序中，模块加载顺序可能会与期待的不同，因此我们最好不要假设模块的加载顺序，否则会容易出 bug。

```js
// ModuleA
require('./moduleD');
require('./moduleB');
console.log('moduleA');

// ModuleB
require('./moduleA');
require('./moduleC');
console.log('moduleB');

// ModuleC
require('./moduleB');
require('./moduleD');
console.log('moduleC');

// ModuleD
require('./moduleA')
require('./moduleC')
console.log('moduleD');
```
如果 ModuleA 最先加载，则会有如下打印
```
moduleB
moduleC
moduleD
moduleA
```
![循环依赖加载方式](红宝书/assets/26-1.png)
---

## 模块系统

### 凑合的模块系统
为按照模块模式提供必要的封装，ES6之前的模块有时候会使用`函数作用域`和`立即调用函数表达式 ( IIFE, Immediately Invoked Function Expression )` 将模块定义封装在匿名闭包中。

```js
// 为模块创建命名空间
var Foo = (function() {
	console.log('foo');
	return {
		foo: 'foo',
		baz: function() {
			console.log(this.foo);
		}
	};
})();
```
**泄露模块模式 ( revealing module pattern )**
这种模式只返回一个对象，其属性是私有数据和成员的引用。

```js
var Foo = (function() {
	var bar = 'bar';
	var baz = function() {
		console.log(bar);
	}

	return {
		bar: bar,
		baz: baz
	};
})();
```
**嵌套模块**
```js
var Foo = (function() {
	var bar = 'bar';

	return {
		bar: bar
	};
})();

foo.baz = (function() {
	return {
		qux: function() {
			console.log('baz');
		}
	};
})();

console.log(Foo.bar); // 'bar'
Foo.baz.qux(); // 'baz'
```
使用外部变量 (类似于给构造器传值)
```js
var outterBar = 'bar';

var Foo = (function(bar) {
	return {
		bar: bar,
		baz: function() {
			console.log('baz');
		}
	};
})(outterBar);
```
如果需要扩展模块，可以在使用 IIFE 的时候将自己作为变量传入。
```js
var Foo = (function () {
	var bar = 'bar';
})();

Foo = (function(preFoo) {
	preFoo.baz = function() {
		console.log('baz');
	}
})(Foo);
```

### CommonJS
CommonJS 规范概述了**同步声明**依赖的模块定义，这个规范主要用于在**服务器端**实现模块化代码组织。

浏览器中使用的模块依赖可以用 CommonJS 定义。

CommonJS 模块语法不能在浏览器中直接运行。

Node.js 使用了轻微修改版本的 CommonJS，这是因为 Node.js 主要在服务器环境下使用，所以不需要考虑网络延迟问题。

CommonJS 模块定义使用 `require()` 指定依赖，使用 `exports对象`定义自己的公共 API。
```js
var moduleB = require('./moduleB');

module.exports = {
	stuff: moduleB.doStuff();
};
```

请求模块会加载相应模块，通常做法是把模块赋值给变量。但赋值给变量不是必须的，调用 `require()` 意味着模块会原封不动地加载进来。

**模块是单例的**，因此一个模块无论被引用多少次，该模块只会被加载一次。模块在第一次加载后会被缓存，后续加载会取得缓存的模块。

在 CommonJS 中，模块加载是同步的。

```js
console.log('moduleA');
if (loadCondition) {
	require('./moduleA');
}
```
当 loadCondition 为 true 时，只有 moduleA 加载完毕后，后面的代码才会继续执行。

值得注意的是，`require()`中的字符串( 模块标识符 )指的是模块文件层级中的位置，它可能是文件本身，也可能指向该目录下的 index.js，也可能是指 node_modules 中的文件。

**module.exports 对象**
```js
module.exports = 'foo';

module.exports = {
	a: 'a',
	b: 'b'
};
// 等价于
module.exports.a = 'a';
module.exports.b = 'b';
```
从上面代码可以看出，`module.exports` 是一个模块暴露给外界的`对象`。

模块的一个主要用途是托管类定义

```js
class A {}
module.exports = A;
```
```js
class A {}
module.exports = new A;
```
要想让 CommonJS 定义的代码在浏览器中运行，需要构筑“桥梁”。因为没有封装的 CommonJS 代码在浏览器中执行会创建全局变量，这显然与模块模式的初衷相悖。

一个常见的解决方案是将模块代码封装在函数闭包中，最终只提供一个文件。

### 异步模块
CommonJS  以**服务端**为目标环境，能够一次性把所有模块都加载到内存。

而**异步模块**( AMD, Asynchronous Module Definition ) 定义的模块则以**浏览器**为目标执行环境，这需要考虑网络延迟问题。

**AMD模块**实现的核心是用函数包装模块定义，这样可以防止声明全局变量。

AMD 模块可以使用字符串标识符指定自己的依赖，而 AMD 加载器会在所有依赖模块加载完毕后立即调用模块工厂函数。

AMD 支持可选地为模块指定字符串标识符

```js
// moduleB 会异步加载
define('moduleA', ['moduleB'], function(moduleB) {
	return {
		stuff: moduleB.doStuff()
	};
});
```

AMD 也支持 `require` 和 `exports` 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块。( Angular 的模块定义风格和这个有点像...

```js
define('moduleA', ['require', 'exports'], function(require, exports) {
	var moduleB = require('moduleB');
	exports.stuff = moduleB.doStuff();
})
```
这种方式也可以支持动态依赖
```js
define('moduleA', ['require'], function(require) {
	if (condition) {
		var moduleB = require('moduleB');
	}
})
```
### 通用模块定义
通用模块定义 ( UMD, Universal Module Definition ) 的出现是为了统一 CommonJS 和 AMD 两个生态的。

本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式 ( IIFE )。
```js
(function(root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD，注册为匿名模块
		define(['moduleB'], factory);
	} else if (typeof module === 'object' && module.exports) {
		// Node —— 不严格支持 CommonJS
		// 但可以在 Node 这样 类CommonJS 的环境下使用
		module.exports = factory(require('moduleB'))
	} else {
		// 浏览器全局上下文 (root 是 window)
		root.returnExports = factory(root, moduleB);
	}
})(this, function(moduleB) {
	return {};
});
```
此模式支持严格 CommonJS 和浏览器全局上下文的变体。不应该期望手写这个包装函数，它应该由构建工具自动生成。开发者只需要关注模块内容，而不是这些样板代码。

这种封装思想非常值得大家学习，模块内容和包装函数可以类比 react 的 ElementType(对节点的描述) 和 Fiber(拥有行为的节点)，也可以被借鉴用来开发低代码平台。

### ES6 模块
随着 ES6 模块规范得到越来越广泛的支持，上面介绍的模式最终会走向没落。尽管如此，学习模块设计发展历史和了解 ES6 模块规范的由来还是非常有用的。CommonJS 和 AMD 之间的冲突正是我们现在想用的 ES6 模块规范诞生的温床。

ES6 最大的一个改进就是引入了模块规范，这个规范全方位简化了之前出现的模块加载器。原生浏览器支持意味着加载器和其他预处理不再需要。

**模块标签及定义**

使用带有 `type="module"` 属性的 \<script> 标签会告诉浏览器相关代码应该作为模块执行。
```js
<script type="module">
	// 模块代码
</script>

<script type="module" src="path/to/myModule.js"></script>
```
所有的模块都会像 \<script defer> 加载的脚本一样顺序执行。解析到 \<script type="module"> 标签后会立即下载模块文件，但会等文档解析完成之后执行，且执行顺序按脚本书写顺序(参考红宝书第二章内容)。 
```html
<!-- 第二个执行 -->
<script type="module"></script>

<!-- 第三个执行 -->
<script type="module"></script>

<!-- 第一个执行 -->
<script></script>
```
加载外部 JS 模块的格式也是同理
```html
<!-- 第二个执行 -->
<script type="module" src="module.js"></script>

<!-- 第三个执行 -->
<script type="module" src="module.js"></script>

<!-- 第一个执行 -->
<script src="module.js"></script>
```
如果这时给 \<script> 加上 `async` 属性，那它既不会等待文档解析完成再执行，其执行顺序也不会按照书写顺序。

不过入口模块还是需要等待其依赖加载完成后才执行。

根据模块的定义，ES6 模块也是单例、只加载一次、第一次加载后会被缓存。

需要注意的是，嵌入模块定义代码不能使用 `import` 加载到其他模块。
```html
<script type="module">
	console.log('moduleA');
</script>
<script type="module">
	// 此处没办法引入 moduleA
</script>
```
只有通过外部文件加载的模块才可以使用 `import` 加载，因此圈入模块只适合作为入口模块。
```html
<script type="module">
	import './moduleA';
</script>
<script type="module" src="./moduleA"></script>
```
提问：为什么在上述代码中，嵌入模块代码可以在书写 `moduleA` 之前执行？(答案在上文的一句话中，如果你不回顾上文就知道答案，那你阅读吸收的能力很强)

ES6 模块的独特之处在于，其既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。当然大多数情况下还是使用第三方工具会更方便，像 webpack、vite 等等。

ES6 的加载过程与 AMD 风格的模块加载非常相似，模块文件按需加载，且后续模块的请求会因为每个依赖模块的网络延迟而同步延迟。

在了解了 ES6 模块加载机制后，我们便能在此基础上进行性能优化。

**模块行为**

ES6 借用了 CommonJS 和 AMD 的很多优秀特性，如
* 模块代码只在加载后执行
* 模块只能加载一次
* 模块是单例
* 模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互
* 模块可以请求加载其他模块
* 支持循环依赖

ES6 模块系统也有自己的行为
* ES6 模块默认在严格模式下执行
* ES6 模块不共享全局命名空间
* 模块顶级 this 的值是 undefined (常规脚本中是 window)
* 模块中的 var 声明不会添加到 window 对象中
* ES6 模块是异步加载和执行的

浏览器会认为使用 \<script type="module"> 和 通过 import 语句加载的 JS 文件 是模块。

**模块导出**
ES6 模块支持 `命名导出` 和 `默认导出`。

导出语句必须在模块顶级，不能嵌套在某个块中
```js
// 允许
export ...

// 不允许
if (condition) {
	export ...
}
```
这一点和 react hooks 类似，react hooks 是对组件本身能力的一种声明扩张，而 export 是模块对外的能力声明。

导出值对模块内部的 JS 执行没有直接影响
```js
// 允许
const foo = 'foo';
export { foo };

// 允许
export const foo = 'foo';

// 允许，但不鼓励
export { foo };
const foo = 'foo';
```
提供别名
```js
const foo = 'foo';
export { foo as myFoo };
```
同时导出多个变量
```js
const foo = 'foo';
const bar = 'bar';
const baz = 'baz';
export { foo, bar as myBar, baz };

// 这里用了 ES6 特性
// 以上导出相当于
export {
	foo: foo,
	myBar: bar,
	baz: baz
};
```
**默认导出**

每个模块只能有一个默认导出
```js
const foo = 'foo';
export default foo;

// 以上导出等价于
export { foo as default };
```
```js
const foo = 'foo';
const bar = 'bar';

export { foo as default, bar }
```
**错误的导出形式**
```js
// 行内默认导出不能出现变量声明
export default const foo = 'foo';

// 只有标识符可以出现在 export 子句中
export { 123 as default }

// 别名只能在 export 子句中出现
export const foo = 'foo' as myFoo;
```

**一般来说，让声明、赋值和导出标识符分开就不容易搞错了，而且还能让 export 语句集中在一块**

**模块导入**

模块可以通过 `import ` 使用其他模块导出的值。与 export 类似，import 必须出现在模块的顶级。

```js
// 允许
import ...

// 不允许
if (condition) {
	import ...
}
```
虽然 `import` 和使用导入值语句的相对位置并不重要，不过还是推荐把导入语句放在模块顶部。

```js
// 允许
import { foo } from './fooModule.js';
console.log(foo); // 'foo'

// 允许，但不鼓励
console.log(foo); // 'foo'
import { foo } from './fooModule.js';
```
当然使用第三方打包工具，出现这种情况可能不会编译通过。

如果是在浏览器中通过标识符原生加载模块，则文件必须带 .js 扩展名，不然可能无法正确解析。如果是通过构建工具或第三方模块加载器打包或解析 ES6 模块，则可能不需要包含文件扩展名。

导入对于模块而言是`只读`的，实际上相当于 const 声明的变量。在使用 * 执行批量导入时，赋值给别名的命名导出就好像使用 `Object.freeze()` 冻结过一样，直接修改导出值是不可能的。

但是我们可以通过暴露的方法对模块进行访问和操作。

```js
import foo, * as Foo from './foo.js';

foo = 'foo'; // 错误
Foo.foo = 'foo'; // 错误
foo.bar = 'bar'; // 允许
```

总体来说，`import` 规则可以类比 `export`
```js
const foo = 'foo', bar = 'bar', baz = 'baz';
export { foo, bar, baz };
export default foo;

import * as Foo from './foo.js';
console.log(Foo.foo); // 'foo'

import { baz as myBaz } from './foo.js';
console.log(myBaz); // 'baz'

import foo from './foo.js';
console.log(foo); // 'foo'

import { default as foo, bar } from './foo.js';
console.log(foo); // 'foo'
console.log(bar); // 'bar'

```

**模块转移导出**

有时候我们会将一个目录下的所有导出放在一个公共导出文件中，比如说一个用于存放页面组件的目录，里面可能会有一个 `reducers.js` 用于统一导出每个页面组件的 `reducer`。

```js
export * from './foo.js';
export * as User from './user.js';
```
值得注意的是，* 导出会忽略掉默认导出。比如上面的代码中如果 foo.js 有默认导出，则该语法会忽略它。

这种情况下，可以通过明确外部模块转移本地导出的值
```js
export { default, foo, bar as myBar } from './foo.js';
```
```js
export { foo as default } from './foo.js';
```

---

## 向后兼容

开发者可以通过编写非模块脚本来兼容不支持模块的浏览器。

```html
// 支持模块的浏览器会执行这段脚本
// 不支持模块的浏览器不会执行这段脚本
<script type="module" src="module.js"></script>

// 支持模块的浏览器不会执行这段脚本
// 不支持模块的浏览器会执行这段脚本
<script nomodule src="fallback.js"></script>
```