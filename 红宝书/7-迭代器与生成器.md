# 迭代

计数循环和数组的 `forEach` 等方法均是 js 的迭代方法。

但这些方法都有缺陷

* 迭代之前需要事先知道如何使用数据结构
* 遍历顺序并不是数据结构固有的



## 迭代器模式

可迭代对象 —— 拥有 Iterable 接口且可以被 Iterator 消费.

迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。



**可迭代协议**

实现 Iterable 接口（可迭代协议）要求同时具备两种能力：

* 支持迭代的自我识别能力
* 创建实现 Iterator 接口的对象的能力

可迭代对象必须有一个属性 `Symbol.iterator` 作为默认迭代器的键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。

实现了 Iterable 接口的内置类型：

* 字符串
* 数组
* 映射
* 集合
* arguments 对象
* NodeList 等 DOM 集合

`Symbol.iterator` 可以在外部直接访问

```js
const num = 1;
const arr = [];

console.log(num[Symbol.iterator]); // undefined
console.log(arr[Symbol.iterator]); // f values () { [native code] }
```

在实际开发中通常不会显示调用这个工厂函数来生成迭代器。

接收可迭代对象的原生语言特性包括：

* for-of 循环
* 数组解构
* Array.from()
* 创建集合
* 创建映射
* Promise.all() 接收由期约组成的可迭代对象
* Promise.race() 接收由七月组成的可迭代对象
* yield* 操作符，在生成器中使用

```js
const arr = [1, 2];

// for-of
for (const el of arr) {
  console.log(el);
}

// 数组解构
const [a, b] = arr;

// 扩展操作符
const arr2 = [...arr];

// Array.from()
const arr3 = Array.from(arr);

// Set
const set = new Set(arr);

// Map
const pairs = arr.map((x, i) => [x, i]);
const map = new Map(pairs);
```

如果对象原型链上的父类实现了 Iterable 接口，那这个对象也实现了这个接口

```js
class FooArray extends Array {}
const fooArr = new FooArray([1, 2]); // FooArray 没有显示定义构造函数，因此传入参数直接传给父类构造函数

for (const el of fooArr) {
  console.log(el);
}

```



## 迭代器协议

迭代器是一种一次性使用的对象。迭代器 API 通过调用 next() 来遍历对象，每次调用都会返回一个 IteratorResult 对象。

```ts
type IteratorResult = {
  done: boolean; // 表示迭代器对象是否已经遍历完毕
  value: any | undefined; // 可迭代对象的下一个值 当值为 undefined 时表示已遍历完
};
```

```js
const arr = [1, 2];

const iter = arr[Symbol.iterator]();
console.log(iter); // ArrayIterator {}

// 执行迭代
console.log(iter.next()); // { done: false, value: 1 }
console.log(iter.next()); // { done: false, value: 2 }
console.log(iter.next()); // { done: true, value: undefined }
console.log(iter.next()); // { done: true, value: undefined }
```

不同的迭代器实例互相独立。

迭代器不是可迭代对象某个时刻的快照绑定，因此如果在遍历过程中遍历对象发生改变，迭代器也会反映相应的状态。

```js
const arr = ['foo', 'baz'];
const iter = arr[Symbol.iterator]();

console.log(iter.next()); // { done: false, value: 'foo' }

// 在数组中间插入值
arr.splice(1, 0, 'bar');

console.log(iter.next()); // { done: false, value: 'bar' }
console.log(iter.next()); // { done: false, value: 'baz' }
console.log(iter.next()); // { done: true, value: undefined }
```

**注意：迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象**

比较显示迭代器和原生迭代器

```js
class Foo {
  [Symbol.iterator]() {
    return {
      next() {
        return { done: false, value: 'foo' };
      }
    }
  }
}
const f = new Foo();
console.log(f[Symbol.iterator]()); // { next: f() {} }

const a = new Array();
console.log(a[Symbol.iterator]()); // Array Iterator {}
```



**自定义迭代器**

```js
class Counter {
  // Counter 的实例应该迭代 limit 次
  constructor(limit) {
    this.count = 1;
    this.limit = limit;
  }
  
  next() {
    if (this.count <= this.limit) {
      return { done: false, value: this.count++ };
    } else {
      return { done: true, value: undefined };
    }
  }
  
  [Symbol.iterator]() {
    return this;
  }
}

const counter = new Counter(3);

for (const i of counter) {
  console.log(i);
}

```

为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。因此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：

```js
class Counter {
  constructor(limit) {
    this.limit = limit;
  }
  
  [Symbol.iterator]() {
    // 如果把这里的 count 提出去，那这个迭代器只能遍历一次
    let count = 1, limit = this.limit;
    
    return {
      next() {
        if (count <= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true, value: undefined };
        }
      }
    };
  }
}

const counter = new Counter(3);

for (const i of counter) { console.log(i); }
// 1
// 2
// 3

for (const i of counter) { console.log(i); }
// 1
// 2
// 3

```

每个以这种方式创建的迭代器也实现了 Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器。

```js
const arr = [];
const iter1 = arr[Symbol.iterator]();
const iter2 = iter1[Symbol.iterator]();

console.log(iter1 === iter2); // true
```

```js
const arr = [3, 1, 4];
const iter = arr[Symbol.iterator]();

for (const i of arr) { console.log(i); }
// 3
// 1
// 4

for (const i of iter) { console.log(i); }
// 3
// 1
// 4
```



> **提前终止迭代器**

迭代器的 `return()`<可选> 用于指定在迭代器提前关闭时执行的逻辑，该方法必须返回一个有效的 IteratorResult 对象。

* for-of
  通过 break  continue  return  或  throw  提前退出
* 解构操作并未消费所有制

```js
class Counter {
  constructor(limit) {
    this.limit = limit;
  }
  
  [Symbol.iterator]() {
    let count = 1, limit = this.limit;
    return {
      next() {
        if (count <= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true };
        }
      },
      return() {
        console.log('Exiting early');
        return { done: true };
      }
    }
  }
}

const counter1 = new Counter(5);
for (const i of counter1) {
  if (i > 2) break;
  console.log(i);
}
// 1
// 2
// 提前退出

const counter2 = new Counter(5);
for (const i of counter2) {
  if (i > 2) throw 'err';
  console.log(i);
}
// 1
// 2
// 提前退出

const counter3 = new Counter(5);
const [a, b] = counter3;
// 提前退出
```

如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的。

```js
const a = [1, 2, 3, 4, 5];
const iter = a[Symbol.iterator]();

for (const i of iter) {
  console.log(i);
  if (i > 2) break;
}
// 1
// 2
// 3

for (const i of iter) {
  console.log(i);
}
// 4
// 5
```









